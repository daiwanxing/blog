import{_ as s,c as a,o as e,a as o}from"./app.270f485a.js";const b=JSON.parse('{"title":"谈谈事件循环(event-loop)","description":"","frontmatter":{},"headers":[{"level":2,"title":"callback-stack","slug":"callback-stack","link":"#callback-stack","children":[]},{"level":2,"title":"","slug":"","link":"#","children":[]}],"relativePath":"js/event-loopV2.md","lastUpdated":1673577875000}'),l={name:"js/event-loopV2.md"},n=o(`<h1 id="谈谈事件循环-event-loop" tabindex="-1">谈谈事件循环(event-loop) <a class="header-anchor" href="#谈谈事件循环-event-loop" aria-hidden="true">#</a></h1><p>事件循环在前端圈子里，是一个经常被谈起的技术知识。互联网上也有很多关于事件循环的技术文章，有写的好的，也有很多都是为了蹭访问量的水文。总之，事件循环的确是一个难懂，需要反复理解并且稍加实践的概念。光在脑子里靠抽象的去理解是不够的，如果能结合实际，写一个例子会更有助于我们理解。</p><p>前端工程师为什么需要了解事件循环，部分人纯粹就是为了应付面试，对还抱有这种想法的人，我认为最多是个初级前端工程师。如果你没有理解事件循环，你就无法知道:</p><ul><li>为什么<code>Promise</code>、<code>MutationObserver</code>、<code>queueMicroTask</code>等 api 的回调任务总是优先于<code>setTimeout</code>执行.</li><li>Vue 中的<code>nextTick</code>这个 api 为什么可以让我们获取到最新的 DOM 并操作.</li><li>UI-Render 到底是在什么时候进行的.</li></ul><p>要想好好讲清楚事件循环, 弄明白上面几个问题，就必须得先讲讲<code>javascript</code>中绕不开的几个概念知识。</p><h2 id="callback-stack" tabindex="-1">callback-stack <a class="header-anchor" href="#callback-stack" aria-hidden="true">#</a></h2><p><code>callback-stack</code>也称之为回调栈， 在 js 中所有的函数都会被放入这个栈中执行，<code>callback-stack</code>遵循 LIFO 的特点。最先被放入到栈中的函数最后被执行,栈中存放每个函数的地方称之为<code>frame</code>，每个<code>frame</code>代表函数被调用一次。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>当 js 引擎执行<code>调用函数</code>这个操作时，才会把该函数推入到<code>callback-stack</code>中。请注意，并不是解析代码的时候 push，而是执行的时候 push。</p></div><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight has-highlighted-lines"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#82AAFF;">baz</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">baz</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#82AAFF;">bar</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">bar</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">   </span><span style="color:#676E95;font-style:italic;">//</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line highlighted"><span style="color:#82AAFF;">foo</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>当 js 执行到上面高亮的一行代码<code>foo()</code>，会将 foo 推入到<code>callback</code>中, 假设此时的栈是 empty 的，那么栈目前的情况通过可视化来描述就是.</p><iframe src="https://codesandbox.io/embed/mystifying-wind-d4p3lo?fontsize=14&amp;theme=dark" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden;" title="mystifying-wind-d4p3lo" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>可以看到执行<code>foo</code>，<code>foo</code>先被推入到栈中，，接着在<code>foo()</code>函数体内执行<code>baz()</code>，此时<code>baz()</code>也随之被推入到栈中，要注意的是，<code>foo()</code>仍未执行完噢，所以<code>foo</code>函数仍然在栈中。继续在<code>baz()</code>函数体内执行代码，遇到了<code>bar()</code>这行函数调用的代码，所以<code>bar()</code>也被推入到栈中。执行完<code>bar()</code>函数中所有的代码后<code>bar()</code>出栈，依次重复这样的操作，直到栈中所有的任务执行完毕，栈为空。</p><h2 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h2>`,13),c=[n];function p(t,d,r,i,y,h){return e(),a("div",null,c)}const D=s(l,[["render",p]]);export{b as __pageData,D as default};
