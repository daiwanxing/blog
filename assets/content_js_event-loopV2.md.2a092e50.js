import{_ as s,c as e,o,Q as a}from"./app.a5d91a3c.js";import"./chunks/theme.027e9549.js";const k=JSON.parse('{"title":"谈谈事件循环(event-loop)","description":"","frontmatter":{},"headers":[{"level":2,"title":"call-stack","slug":"call-stack","link":"#call-stack","children":[]},{"level":2,"title":"task","slug":"task","link":"#task","children":[]},{"level":2,"title":"microTask","slug":"microtask","link":"#microtask","children":[]},{"level":2,"title":"事件循环的运行机制","slug":"事件循环的运行机制","link":"#事件循环的运行机制","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"relativePath":"content/js/event-loopV2.md","lastUpdated":1678631966000}'),n={name:"content/js/event-loopV2.md"},c=a(`<h1 id="谈谈事件循环-event-loop" tabindex="-1">谈谈事件循环(event-loop) <a class="header-anchor" href="#谈谈事件循环-event-loop" aria-hidden="true">#</a></h1><p>事件循环在前端圈子里，是一个经常被谈起的技术知识。互联网上也有很多关于事件循环的技术文章，有写的好的，也有很多都是为了蹭访问量的水文。总之，事件循环的确是一个难懂，需要反复理解并且稍加实践的抽象知识。光在脑子里靠抽象的去理解是不够的，如果能结合实际，写一个例子会更有助于我们理解。</p><p>前端工程师为什么需要了解事件循环，部分人纯粹就是为了应付面试，对还抱有这种想法的人，我认为最多是个初级前端工程师。如果你没有理解事件循环，你就无法知道:</p><ul><li>为什么<code>Promise</code>、<code>MutationObserver</code>、<code>queueMicroTask</code>等 api 的回调任务总是优先于<code>setTimeout</code>执行.</li><li>Vue 中的<code>nextTick</code>这个 api 为什么可以让我们获取到最新的 DOM 并操作.</li><li>UI-Render 到底是在什么时候进行的.</li></ul><p>要想好好讲清楚事件循环, 弄明白上面几个问题，就必须得先讲讲<code>javascript</code>中绕不开的几个概念知识。</p><h2 id="call-stack" tabindex="-1">call-stack <a class="header-anchor" href="#call-stack" aria-hidden="true">#</a></h2><p><code>call-stack</code>也称之为调用栈， 在 js 中所有的函数都会被放入这个栈中执行，<code>call-stack</code>遵循 LIFO 的特点。最先被放入到栈中的函数最后被执行,栈中存放每个函数的地方称之为<code>frame</code>，每个<code>frame</code>代表函数被调用一次。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>当 js 引擎执行<code>调用函数</code>这个操作时，才会把该函数推入到<code>call-stack</code>中。请注意，并不是解析代码的时候 push，而是执行的时候 push。</p></div><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight has-highlighted-lines" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#82AAFF;">baz</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">baz</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#82AAFF;">bar</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">bar</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">   </span><span style="color:#676E95;font-style:italic;">//</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line highlighted"><span style="color:#82AAFF;">foo</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>当 js 执行到上面高亮的一行代码<code>foo()</code>，会将 foo 推入到<code>call</code>中, 假设此时的栈是 empty 的，那么栈目前的情况通过可视化来描述就是.</p><iframe src="https://codesandbox.io/embed/mystifying-wind-d4p3lo?fontsize=14&amp;theme=dark" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden;" title="mystifying-wind-d4p3lo" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>可以看到执行<code>foo</code>，<code>foo</code>先被推入到栈中，，接着在<code>foo()</code>函数体内执行<code>baz()</code>，此时<code>baz()</code>也随之被推入到栈中，要注意的是，<code>foo()</code>仍未执行完噢，所以<code>foo</code>函数仍然在栈中。继续在<code>baz()</code>函数体内执行代码，遇到了<code>bar()</code>这行函数调用的代码，所以<code>bar()</code>也被推入到栈中。执行完<code>bar()</code>函数中所有的代码后<code>bar()</code>出栈，依次重复这样的操作，直到栈中所有的任务执行完毕，栈为空。</p><h2 id="task" tabindex="-1">task <a class="header-anchor" href="#task" aria-hidden="true">#</a></h2><p>task 以前在被人总是叫做宏任务队列，我查阅了很多相关的资料。task 最准确的翻译是叫做任务队列，为什么我能得出这个结论？是因为我从 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops" target="_blank" rel="nofollow noopener noreferrer">whatwg-event-loop</a> 查阅了规范，规范明确定义了事件循环包含<code>task queue</code> 和 <code>microtask queue</code>.</p><p>而 <code>task queue</code> 的数据结构并不是一个 queue，而是<code>set</code>（一个存放所有的 task 的集合）</p><blockquote><p>Task queues are sets, not queues, because the event loop processing model grabs the first runnable task from the chosen queue, instead of dequeuing the first task.</p></blockquote><p><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" target="_blank" rel="nofollow noopener noreferrer">processing-model</a>总是从<code>task queue</code>中取出第一个能运行的 task 并执行，而不是像队列一样采用 FIFO 那种方式取出任务。</p><p>我想强调的是什么叫做<code>runnable task</code>也就是<em><strong>可运行的task</strong></em>。</p><p>在浏览器环境中，除了<code>setTimeout</code>等api是一个<code>task</code>，对于<code>Input Event</code>也是一个task，例如我们给某个dom注册一个点击事件, 那么这个事件的回调会放入到<code>task</code>中。为什么task不是基于队列这一数据结构设计的？因为队列最大的特点是FIFO(先进先出)！如果注册的click-event回调放到一个队列的头部，紧接着放入一个<code>setTimeout</code>的回调。那么想要执行延时器的回调函数是不是得先出队。如果要出队，是不是得让<code>click-event</code>的task先出队。所以问题就来了，<code>click-event</code>如果非人为出触发的话，就被执行肯定非常不合理啊！所以我总算是明白了什么叫做<code>runnable task</code>. 以及为什么不是设计成队列的数据结构。而是一个<code>set</code>也称之为集合。</p><p><code>task queue</code>中的任务总是优先于<code>microtask queue</code>执行，当执行一个 task 时，会将 task 内的所有的<code>microTask</code>放入到 <code>microTask queue</code>.</p><p>在浏览器运行环境中，像<code>setTimeout</code>、<code>setInterval</code>等这样的 api 执行的时候会将其回调函数 push 到 <code>task queue</code>中。等待 processing-model 取出并执行。</p><h2 id="microtask" tabindex="-1">microTask <a class="header-anchor" href="#microtask" aria-hidden="true">#</a></h2><p>microTask 也称之为<code>微任务</code>, microTask 不等同于 <code>task</code>， 所有的<code>microtask</code>都会放入到<code>microtask queue</code>。根据规范定义，<code>microTask queue</code>是一个<code>queue</code>，而不是<code>Set</code>. 那么根据队列的特性，先进来的任务先会被执行并出队，直到队列为空。</p><blockquote><p>Each event loop has a microtask queue, which is a queue of microtasks, initially empty. A microtask is a colloquial way of referring to a task that was created via the queue a microtask algorithm.</p></blockquote><p><code>microTask-queue</code>中的所有的 task 全部执行完毕后，当队列为空时，才会重新开始执行下一个 Task。注意，如果在浏览器环境下，当<em><strong>所有的 microTask 出队后，会触发一次 UI 的 Render</strong></em>, 也就是说当微任务队列为空后，浏览器渲染一次页面, 更新DOM树。</p><p><code>microtask</code>相关的 api 有<code>Promise</code>、<code>Mutation-Observer</code>，<code>queueMicroTask</code>eg...</p><h2 id="事件循环的运行机制" tabindex="-1">事件循环的运行机制 <a class="header-anchor" href="#事件循环的运行机制" aria-hidden="true">#</a></h2><p>为了更好的去了解事件循环，下面提供一个示例去了解事件循环的工作机制</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">const foo = &quot;foo&quot;;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">function printFoo() </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">setTimeout</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">fooFn</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">print Foo!</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">},</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3000</span><span style="color:#A6ACCD;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">fetchData</span><span style="color:#A6ACCD;">();</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">printFoo();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">function fetchData() </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    const p </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Promise</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">res</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">rej</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#82AAFF;">res</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">fetch done</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    p</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">res</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(res));</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>当 js 引擎加载这个 script 脚本的时候，首先会立刻执行<code>const foo = &#39;foo&#39;</code>这行同步代码。接着执行<code>printFoo</code>函数调用，调用 <code>printFoo</code> 函数，会将函数 push 到<code>call-stack</code>中。在<code>printFoo()</code>函数体内，js 又执行了<code>setTimeout</code>这个 api，并将其回调函数<code>fooFn()</code>推入到<code>task</code>中，这个<code>fooFn</code>会在三秒后被执行（不一定是三秒，如果有任务长期在线程中执行大量计算导致线程无法执行其他任务，那么这个时间会持续很久）。</p><p>将其回调函数<code>fooFn()</code>推入到<code>task</code>后，接着立即执行<code>fetchData()</code>函数，会将<code>fetchData()</code>推入到<code>call-stack</code>中。在<code>fetchData</code>函数体内，立即将<code>new promise</code>内的匿名函数推入到<code>call-stack</code>中，并将 promise 实例复制给常量<code>p</code>.</p><p>接着并调用<code>then</code>将回调函数放入<code>microTask-queue</code>中。</p><p>现在整个事件循环的可视化图如下所示</p><p><img src="https://picx.zhimg.com/80/v2-07a789fd4003f8d4c28dfe086605f77d_r.jpg" alt=""></p><p>根据上面的预先说的三点概念，<code>processing-model</code>会从<code>call-stack</code>执行完所有的同步任务后，也就是执行完这三个函数后，此时没有任何同步的任务了。接着从<code>Microtask Queue</code>取出<code>p.then</code>中的匿名函数放入到<code>call-stack</code>中执行完毕，此刻微任务队列为空， 开始绘制一次界面。</p><p>本次event-loop就此结束。 但是在<code>Task Queue</code>中还有一个<code>fooFn()</code>并未执行。接下来重复上述步骤，开始取出<code>Task Queue</code>中的最近的一个的task并放入到<code>call-stack</code>中执行。一直重复.....</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h2><ul><li>task-queue 是存放的是一组任务的集合，task-queue的数据结构并不是队列而是Set，task总是会grab第一个可以runable的任务放入到call-stack中运行。</li><li>microTask-queue 是存放一组微任务的队列，具有FIFO的特点，processing-model会不断地从microTask-queue取出一个个的microTask push 到call-stack执行，重复此步骤直到MicroTask Queue为空。</li><li>当task内的所有的microTask执行完毕后，浏览器会渲染一次UI。</li></ul>`,38),l=[c];function p(t,r,d,i,F,y){return o(),e("div",null,l)}const A=s(n,[["render",p]]);export{k as __pageData,A as default};
