import{_ as s,f as a,h as n,R as l}from"./chunks/framework.0f2d6a02.js";const o="/blog/iterator.png",A=JSON.parse('{"title":"元属性编程 - Symbol","description":"","frontmatter":{},"headers":[],"relativePath":"articles/javascript/metaPropertyAboutSymbol.md","lastUpdated":1680597939000}'),p={name:"articles/javascript/metaPropertyAboutSymbol.md"},e=l(`<h1 id="元属性编程-symbol" tabindex="-1">元属性编程 - Symbol <a class="header-anchor" href="#元属性编程-symbol" aria-label="Permalink to &quot;元属性编程 - Symbol&quot;">​</a></h1><h2 id="es2015-带来了-symbol" tabindex="-1">ES2015 带来了 Symbol <a class="header-anchor" href="#es2015-带来了-symbol" aria-label="Permalink to &quot;ES2015 带来了 Symbol&quot;">​</a></h2><p>ES2015 (简称 ES6) 为 JavaScript 开发者带来了一个新的基本属性: <code>Symbol</code>。</p><p>本文不会介绍 <code>Symbol</code> 的相关知识以及可用的业务场景，如果您还未了解使用过 <code>Symbol</code>， 建议阅读相关资料后再阅读本文。</p><p>除了在我们的代码内声明自定义的 <code>symbol</code> 外, ES6 还为我们带来了几种内建 Symbol（也称之为通用 Symbol - as well know symbol）。</p><p>这些内建的 symbol 可以让开发者对 JS 语法掌握更多的控制权，甚至改写语言默认的行为，这种能力称之为<strong>元编程</strong>。</p><p>我们在编写业务代码的时候，几乎用不到<strong>元编程</strong>这样的能力，元编程的使用场景更多的是在开发框架、库等方面。（作者本人只在编写业务轮子的时候使用过）。</p><p>JS 内建的 <code>Symbol</code> 属性有长达 10 多种，下面列举可能常用的几种内建 Symbol</p><ul><li>iterator</li><li>toPrimitive</li><li>replace</li><li>isConcatSpreadable</li><li>hasItance</li><li>search</li><li>split</li><li>toStrintTag</li><li>....</li></ul><h2 id="symobl-iterator" tabindex="-1">[Symobl.iterator] <a class="header-anchor" href="#symobl-iterator" aria-label="Permalink to &quot;[Symobl.iterator]&quot;">​</a></h2><p>大家有没有想过一个这样一个问题，像 <code>Array</code>，<code>Set</code>，<code>Map</code> 这样的数据类型。我们可以通过 <code>for..in</code>、或者展开运算符 <code>[...new Set()]</code> 遍历对象的属性。可是唯独 plain object 却无法这样做到。</p><p>当我们尝试为一个 plain object 进行 <code>[...{}]</code> 得到的会是一个错误信息</p><div class="danger custom-block"><p class="custom-block-title">DANGER</p><p><code>Uncaught TypeError: {} is not iterable</code>。</p></div><p>根据错误信息我们可知，普通对象不能迭代。 但是 <code>Array</code>, <code>Set</code> 等也是对象，为什么它们就能迭代呢？</p><p>究其原因，是因为像 <code>Array</code>，<code>Set</code>，<code>Map</code> 这样的对象内部有个迭代器对象。当我们对这些可迭代对象进行迭代的时候，会自动调用内置的迭代器对象。而普通对象没有内置的迭代器对象，因此无法被迭代。</p><p>你可能很好奇，这个内置的迭代器对象到底长啥样。</p><p>其实这个迭代器就是本文要讨论的 <code>Symbol.iterator</code>。</p><p>例如，我们声明了一个名为 <code>foo</code> 的 <code>Map</code> 对象。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> foo </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Map</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>我们可以访问 <code>foo</code> 的 <code>Symbol.iterator</code> 元属性得到一个返回迭代器对象的工厂函数。当执行这个函数后我们可以得到一个 <code>Map</code> 的迭代器对象。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">foo[Symbol</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">iterator]</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// ƒ values() { [native code] }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> iterator </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> foo[Symobl</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">iterator]()</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// iterator function</span></span>
<span class="line"></span></code></pre></div><p>JS 内置的可遍历的对象都实现了 <code>Symbol.iterator</code> 方法，以支持迭代器协议（iterator protocol），迭代器协议规定了一个统一的接口，使得数据结构可以通过相同的方式进行迭代操作。</p><p>当遍历可迭代对象的时候， JS 会自动调用这些可迭代对象的内置迭代器。</p><p>如果我们自行为普通对象实现一个迭代器对象适配迭代器协议，是不是同样也能实现对普通对象的迭代呢？</p><p>答案：<strong>YES ！</strong></p><p>实现一个迭代器对象很简单，只需要适配迭代器协议的接口即可。</p><div class="info custom-block"><p class="custom-block-title">说明</p><p>迭代器协议（Iterator protocol）是 JavaScript 官方定义的一种协议，规定了一种标准的迭代器接口，用于遍历任意对象。这个协议的具体约定如下：</p><ul><li><p>迭代器对象必须实现 next() 方法，该方法返回一个对象，对象中包含以下两个属性：</p><ul><li>value：表示当前迭代位置的值。</li><li>done：表示迭代器是否已经遍历完了所有值。</li></ul></li><li><p>当迭代器对象的 next() 方法被调用时，如果迭代器还有下一个值，则返回一个形如 { value: value, done: false } 的对象，其中 value 属性为当前值，done 属性为 false。</p></li><li><p>当迭代器对象的 next() 方法被调用时，如果迭代器已经遍历完了所有值，则返回一个形如 { value: undefined, done: true } 的对象，表示迭代已经结束。</p></li></ul></div><p>根据上面的规范，我们一步步来为普通对象 <code>foo</code> 实现一个迭代器对象。</p><p>首先，需要声明一个返回迭代器的工厂函数</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">genIterator</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">   </span><span style="color:#676E95;font-style:italic;">// TODO</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>将 <code>genIterator</code> 赋值给 <code>foo[Symbol.iterator]</code></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> foo </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#F07178;">bar</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">bar</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#F07178;">baz</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">baz</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#A6ACCD;">foo[Symbol</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">iterator] </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> genIterator</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>接着我们需要实现 <code>genIterator</code> 的以下功能，</p><ul><li><code>genIterator()</code> 需要返会一个迭代器对象</li><li>该迭代器对象需要实现一个 <code>next()</code> 方法</li><li>每次调用 <code>next()</code> 需要返回固定格式的对象值 <code>{ done: boolean; value: any }</code></li><li>当调用 <code>next()</code> 遍历完毕后, 需要返回 <code>{ done: true, value: undefined }</code> 表示迭代结束</li></ul><p>有了上面的需求，接下来就只剩完成这些需求了。让我们一步步来实现它。</p><blockquote><p><code>genIterator()</code> 需要返会一个迭代器对象，该迭代器对象需要实现一个 <code>next()</code> 方法</p></blockquote><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">genIterator</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">iterator</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      next</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">         </span><span style="color:#676E95;font-style:italic;">// TODO</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">iterator</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>根据上面的定义，我们在 <code>genIterator</code> 函数中声明了一个 <code>iterator</code> 作为迭代器对象，并且该对象已具有 <code>next</code> 函数。</p><blockquote><p>每次调用 <code>next()</code> 需要返回固定格式的对象值 <code>{ done: boolean; value: any }</code></p></blockquote><p>根据定义，每次调用 <code>next()</code> 都需要返回指定格式的对象，这里我们需要实现如何设置 <code>done</code> 的值和 <code>value</code> 的值。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight has-highlighted-lines"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">genIterator</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">iterator</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      next</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line highlighted"><span style="color:#F07178;">         </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line highlighted"><span style="color:#F07178;">            done</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null,</span></span>
<span class="line highlighted"><span style="color:#F07178;">            value</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null</span></span>
<span class="line highlighted"><span style="color:#F07178;">         </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">iterator</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>很简单，我们的需求是能够遍历普通对象，每次遍历可以得到每一项 key 和 value。我们可以借助 <code>Object.keys</code> 得到对象所有可枚举的键名，并且需要设置一个下标，以便每次调用 <code>next()</code> 偏移下标值。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight has-highlighted-lines"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">genIterator</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line highlighted"><span style="color:#F07178;">   </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">anchor</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line highlighted"><span style="color:#F07178;">   </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">keys</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">keys</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this</span><span style="color:#F07178;">) </span><span style="color:#676E95;font-style:italic;">// this 指向被调用该函数的对象</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">iterator</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      next</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">         </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            done</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null,</span></span>
<span class="line"><span style="color:#F07178;">            value</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null</span></span>
<span class="line"><span style="color:#F07178;">         </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">iterator</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>获取到了对象所有可枚举的键名后，每次调用 <code>next()</code> 方法时我们可以对 <code>done</code> 和 <code>value</code> 设置值了。其中，<code>done</code> 的是一个布尔值，如果为 <code>true</code> 表示遍历已结束。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight has-highlighted-lines"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">genIterator</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">anchor</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">keys</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">keys</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// this 指向被调用该函数的对象</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">iterator</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line highlighted"><span style="color:#F07178;">      </span><span style="color:#82AAFF;">next</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line highlighted"><span style="color:#F07178;">         </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">done</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">anchor</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&gt;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">keys</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">length</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">;</span></span>
<span class="line highlighted"><span style="color:#F07178;">         </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line highlighted"><span style="color:#F07178;">            </span><span style="color:#A6ACCD;">done</span><span style="color:#89DDFF;">,</span></span>
<span class="line highlighted"><span style="color:#F07178;">            value</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">done</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">?</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">undefined</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line highlighted"><span style="color:#F07178;">                key</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">keys</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">anchor</span><span style="color:#F07178;">]</span><span style="color:#89DDFF;">,</span></span>
<span class="line highlighted"><span style="color:#F07178;">                value</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">keys</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">anchor</span><span style="color:#89DDFF;">++</span><span style="color:#F07178;">]]</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#F07178;">         </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">iterator</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>有个小细节，这里的 <code>next()</code> 函数由之前的普通函数改写成了箭头函数，这是为了方便获取父级的 <code>this</code>。</p><p>之前提到过，如果迭代结束，需要将 <code>next()</code> 函数返回的 <code>value</code> 设置为 <code>undefined</code> 并且 <code>done</code> 设置为 <code>true</code>。</p><p>这里我通过判断 <code>anchor</code> 的索引是否大于可枚举的长度来确定是否迭代结束。</p><p>现在，为普通对象适配一个迭代器协议的迭代器对象功能就实现了，剩下的就是验证是否可用。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> foo </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">foooo</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">age</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">1000</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">sex</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">unknown</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">foo[Symbol</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">iterator] </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> genIterator</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>对 <code>foo</code> 进行使用展开运算符会获取每次 <code>next()</code> 返回的值</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">[</span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;">foo]</span></span>
<span class="line"></span></code></pre></div><p>其执行结果如下图所示：</p><p><img src="`+o+'" alt="实现一个迭代器"></p><h2 id="🎉-最后" tabindex="-1">🎉 最后 <a class="header-anchor" href="#🎉-最后" aria-label="Permalink to &quot;🎉 最后&quot;">​</a></h2><p>现在我们通过 <code>Symbol.iterator</code> 元属性，成功为一个普通对象实现了迭代器接口，让其具有更加强大的遍历操作。</p><p>元编程可以让开发者自己实现语言某个方面的特性，这种特性太棒了！</p>',57),t=[e];function c(r,y,F,D,i,d){return a(),n("div",null,t)}const h=s(p,[["render",c]]);export{A as __pageData,h as default};
