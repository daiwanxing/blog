import{_ as e,o as s,c as a,a as t}from"./app.e1b5a037.js";const u=JSON.parse('{"title":"Git 命令","description":"","frontmatter":{},"headers":[{"level":2,"title":"git restore --staged <file>","slug":"git-restore-staged-file","link":"#git-restore-staged-file","children":[]},{"level":2,"title":"git log","slug":"git-log","link":"#git-log","children":[]},{"level":2,"title":"git reset [--hard]？<commit-id>","slug":"git-reset-hard-commit-id","link":"#git-reset-hard-commit-id","children":[]},{"level":2,"title":"git reflog","slug":"git-reflog","link":"#git-reflog","children":[]},{"level":2,"title":"git checkout -- <file>","slug":"git-checkout-file","link":"#git-checkout-file","children":[]},{"level":2,"title":"fast-forward","slug":"fast-forward","link":"#fast-forward","children":[]},{"level":2,"title":"git stash","slug":"git-stash","link":"#git-stash","children":[]},{"level":2,"title":"cherry-pick","slug":"cherry-pick","link":"#cherry-pick","children":[]},{"level":2,"title":"git branch","slug":"git-branch","link":"#git-branch","children":[]},{"level":2,"title":"打标签","slug":"打标签","link":"#打标签","children":[]},{"level":2,"title":"git merge --squash","slug":"git-merge-squash","link":"#git-merge-squash","children":[]},{"level":2,"title":"git rebase","slug":"git-rebase","link":"#git-rebase","children":[]},{"level":2,"title":"git 相对引用","slug":"git-相对引用","link":"#git-相对引用","children":[]},{"level":2,"title":"git 撤销变更","slug":"git-撤销变更","link":"#git-撤销变更","children":[]},{"level":2,"title":"git cherry-pick","slug":"git-cherry-pick","link":"#git-cherry-pick","children":[]},{"level":2,"title":"交互式 rebase","slug":"交互式-rebase","link":"#交互式-rebase","children":[]}],"relativePath":"git/index.md","lastUpdated":1678238701000}'),i={name:"git/index.md"},l=t(`<h1 id="git-命令" tabindex="-1">Git 命令 <a class="header-anchor" href="#git-命令" aria-hidden="true">#</a></h1><h2 id="git-restore-staged-file" tabindex="-1">git restore --staged &lt;file&gt; <a class="header-anchor" href="#git-restore-staged-file" aria-hidden="true">#</a></h2><p><code>git restore --staged</code> 一般用来对放入到暂存区的文件恢复到未提交的状态</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">git</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">add</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">/.</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;"># 此刻已经将当前 .git 所在目录下的所有变动了的文件暂存到了缓冲区</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFCB6B;">git</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">restore</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--staged</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">.</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;"># 将缓冲区中的所有的文件全部回滚到工作区</span></span>
<span class="line"></span></code></pre></div><h2 id="git-log" tabindex="-1">git log <a class="header-anchor" href="#git-log" aria-hidden="true">#</a></h2><p><code>git log</code> 负责打印 git commit 的历史记录，如果觉得查看不方便， 可以使用 <code>git log --pretty=oneline</code> 美化打印。</p><p>如果想看到分支详细图，还可以使用 <code>git log --graph</code> 查看。</p><h2 id="git-reset-hard-commit-id" tabindex="-1">git reset [--hard]？&lt;commit-id&gt; <a class="header-anchor" href="#git-reset-hard-commit-id" aria-hidden="true">#</a></h2><p><code>git reset</code> 命令类似于时光穿梭，可以让你回退到指定的 commit</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">git</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">reset</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--hard</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">HEAD^</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;"># 移动到 HEAD 往前的一个commit, 在移动之前，当前 HEAD 所在的那个 commit 将会被丢弃</span></span>
<span class="line"></span></code></pre></div><h2 id="git-reflog" tabindex="-1">git reflog <a class="header-anchor" href="#git-reflog" aria-hidden="true">#</a></h2><p>前面用 <code>git reset</code> 命令通过&quot;时光穿梭&quot;回退到了过去的节点，万一我们又想回到现在该怎么办。如果你记得 最新的那个commit id，可以直接</p><p><code>git reset --hard &lt;commit-id&gt;</code> 回到最新的版本。实在不记得了也没关系。</p><p><code>git reflog</code> 记录了我们每一次 git 操作的历史记录，可以借助这个命令，找到之前提交的那个最新的 commit-id.</p><h2 id="git-checkout-file" tabindex="-1">git checkout -- &lt;file&gt; <a class="header-anchor" href="#git-checkout-file" aria-hidden="true">#</a></h2><p>如果想对<strong>工作区</strong>的文件中的修改全部撤销，可以使用该命令，请记住，<strong>这个命令只能用于工作区的文件改动的撤销</strong>。添加到了暂存区的改动是无法通过这个命令撤销。</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">git</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">checkout</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">main.txt</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;"># 必须带上 -- 这个flag</span></span>
<span class="line"></span></code></pre></div><p><code>git checkout -- &lt;file&gt;</code> 这个命令还可以对误删的文件进行撤回操作，例如我们在工作区误删了 A 文件，此时这个A 文件还没有被添加到暂存区，则可以使用这个命令撤销删除的操作</p><h2 id="fast-forward" tabindex="-1">fast-forward <a class="header-anchor" href="#fast-forward" aria-hidden="true">#</a></h2><blockquote><p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。</p></blockquote><p>使用 <code>--no-ff</code> 方式禁止 fast-forward 模式。</p><p>那么 <code>--no-ff</code> 这个命令什么场景下用？什么是 fast-forward 模式？</p><p>问题先一个个解决。</p><p>如果在 dev 分支 提交了一个 commit，我们需要切换到 master 分支 merge 这些commit。</p><div class="language-git"><button title="Copy Code" class="copy"></button><span class="lang">git</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">git switch master</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">git merge dev</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>我们一般都会这样做，<code>fast-forward</code> 模式是 enabled，这样当 master 分支 merge 时，git就会在merge时生成一个新的commit。</p><p>如果我们不需要这样的信息，可以直接 <code>git merge --no-ff -m &quot;merge-it&quot; dev</code></p><h2 id="git-stash" tabindex="-1">git stash <a class="header-anchor" href="#git-stash" aria-hidden="true">#</a></h2><p>假设一个这样的场景，小帅在自己新建的 dev 分支开发到一半，被产品经理喊去修改一个紧急的线上bug， 线上代码部署在 master 分支。小帅脑海里第一想到的是先切换到 master 分支，然后在 master 分支中新签出一个 issue 分支。但是切换到 master 分支之前，得先暂存 dev 分支中的代码。虽然可以本地提交一个 dev 的commit，但是小帅现在还不想提交。</p><p>有没有一个办法可以暂存 dev 中的代码且不提交呢？</p><p>接下来，就该 <code>git stash</code> 出场了。<code>git stash</code> 命令可以暂存本地的代码。小帅也同时想到了这个命令，于是他打开 <code>cmd</code> 飞快的敲入以下几个命令：</p><div class="language-git"><button title="Copy Code" class="copy"></button><span class="lang">git</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">git stash</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">git switch -b issue-01</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>接下来愉快的去修 bug 去了。等小帅 修复好了 issue 分支的代码并合并到主分支后，接下来又切换到了 dev 分支继续愉快的开发了~</p><div class="language-git"><button title="Copy Code" class="copy"></button><span class="lang">git</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">git switch dev</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">git stash pop # 通过该命令取出暂存了的代码, 执行该命令后，暂存区里的记录将被删除</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>每执行一次 <code>git stash pop</code> 都会从栈顶取出当前 frame 的代码，直到栈为空。</p><div class="warning custom-block"><p class="custom-block-title">注意</p><p><code>git stash</code> 会同时暂存工作区和暂存区的改动。 可以用 <code>git stash list</code> 查看所有暂存的记录</p></div><h2 id="cherry-pick" tabindex="-1">cherry-pick <a class="header-anchor" href="#cherry-pick" aria-hidden="true">#</a></h2><p>小帅解决了产品经理提出的问题后，继续在 dev 分支开发，但是转念一想，dev 分支就是从 master 分支签出来的，那么岂不是 dev 分支也有这个 bug，那怎么在 dev 分支也修复这个 bug 呢？</p><p>幸好聪明的小帅灵机一动，想到了 <code>cherry pick</code>，只要从 master 分支找到解决那个 bug 的 commit-id, cherry-pick 这个 commit 不就解决了吗！于是小帅立即打开 <code>cmd</code> 敲出如下面命令：</p><div class="language-git"><button title="Copy Code" class="copy"></button><span class="lang">git</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">git switch dev</span></span>
<span class="line"><span style="color:#A6ACCD;">git cherry-pick &lt;commit-id&gt; # 找到 issue 分支提交的那个 commit-id</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h2 id="git-branch" tabindex="-1">git branch <a class="header-anchor" href="#git-branch" aria-hidden="true">#</a></h2><p>如果想要检测工作区有哪些分支，可以使用 <code>git branch</code> 查看。 如果要删除某个未受保护的分支，可以使用 <code>git branch -d &lt;branch-name&gt;</code>。</p><p><code>git branc -D</code> 是强行删除某个分支。</p><h2 id="打标签" tabindex="-1">打标签 <a class="header-anchor" href="#打标签" aria-hidden="true">#</a></h2><p>标签是为某个 commit 打上一个易懂的名称。我们一般用打标签控制系统某个 commit 代表的版本。</p><blockquote><p>Git可以使用2种标签：轻标签和注解标签。打上的标签是固定的，不能像分支那样可以移动位置。</p></blockquote><p>我们可以使用 <code>git tag &lt;tagName&gt;</code> 为某个 commit 打上标签。要查看所有的 tag， 可以输入 <code>git tag</code> 查看。</p><p>前面我们提到过 git 有两种标签，直接通过 <code>git tag &lt;tagName&gt;</code> 称之为<strong>轻标签</strong>，那么如何创建<strong>注解标签</strong>呢？</p><p>其实加一个 <code>-a</code> 的参数就可以了。例如，<code>git tag -a 1.0.1 -m &lt;release_your_note&gt;</code>， 。</p><p>如果要删除标签，和删除分支一样的操作， <code>git tab -d &lt;tagName&gt;</code> 即可。</p><p>最后，我们需要将新建的 tag 提交到远程仓库，需要输入：<code>git push origin &lt;branch_name&gt; --tags</code></p><h2 id="git-merge-squash" tabindex="-1">git merge --squash <a class="header-anchor" href="#git-merge-squash" aria-hidden="true">#</a></h2><p><code>--squash</code> 会汇合要 merge 的分支所有的提交到当前的 branch 中，然后在当前 branch 继续 commit 汇合了所有提交的代码。</p><p><code>--squash</code> 参数并不会 merge 要合并的分支，它只是将要 merge 的分支所有的提交全部放到当前的分支中。</p><h2 id="git-rebase" tabindex="-1">git rebase <a class="header-anchor" href="#git-rebase" aria-hidden="true">#</a></h2><p><code>git rebase</code> 作用和 <code>git merge</code> 类似，但是使用 <code>git rebase</code> 能够让不同分支的代码合并到主分支的 commit 时间线更加清晰明了。</p><h2 id="git-相对引用" tabindex="-1">git 相对引用 <a class="header-anchor" href="#git-相对引用" aria-hidden="true">#</a></h2><p>使用相对引用，可以更容易的将 HEAD 移动到指定的 commit, 而通过 hash 值的话不容易阅读也不容易记，而且还需要通过 <code>git log</code> 查看指定的 commit 的 hash 值。</p><p>相对引用有两种用法：</p><ul><li>使用 ^ 向上移动 1 个提交记录</li><li>使用 ~&lt;num&gt; 向上移动多个提交记录，如 ~3</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>假如当前的 branch 是 main 分支 且 HEAD 默认指向的是 main 分支的最近一次提交记录，所以 main^ 相当于“main 的父节点”。main^^ 是 main 的第二个父节点</p></div><p><code>git checkout HEAD^</code></p><p><code>git checkout HEAD^^</code></p><p>这种输入的方式，比使用 commit 的哈希值要快捷多了！</p><p>如果你想在提交树中向上移动很多步的话，敲那么多 ^ 貌似也挺烦人的，Git 当然也考虑到了这一点，于是又引入了操作符 ~。</p><p>例如， <code>git checkout HEAD~4</code>, 表示向上移动4步，这样比使用 HEAD 更加快捷。</p><p>那么，移动分支有什么用呢？</p><p>假如，我们想让 main 分支指向 HEAD 的第三级提交，可以这样做：</p><p><code>git branch -f main HEAD~3</code>, 其中, <code>-f</code> 表示让分支指向另一个提交。</p><h2 id="git-撤销变更" tabindex="-1">git 撤销变更 <a class="header-anchor" href="#git-撤销变更" aria-hidden="true">#</a></h2><p>如果要撤销对 commit 后的文件的更改，git 提供了两个命令可以做到变更撤销</p><ul><li>git reset</li><li>git revert</li></ul><p><code>git reset</code> 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”, git reset 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。</p><p><code>git reset HEAD^</code> 回退 HEAD 指向的上一个 commit。</p><blockquote><p>在reset之前的提交可以参照ORIG_HEAD。Reset错误的时候，在ORIG_HEAD上reset 就可以还原到reset前的状态。</p></blockquote><p><code>git reset HEAD</code> 回退 HEAD 指向当前的 commit。</p><p><code>git revert</code> 我的理解也是撤销更改，但是 <code>git reset</code> 仅仅是撤销本地的 commit 的更改, 而 <code>git revert</code> 是撤销已经同步到了远程仓库的更改。</p><p>回退并不是真正意义上的往回走，而是达到类似于删除旧的 commit 的历史记录的效果。</p><h2 id="git-cherry-pick" tabindex="-1">git cherry-pick <a class="header-anchor" href="#git-cherry-pick" aria-hidden="true">#</a></h2><p>如果希望将 某个分支下的 commit，例如我们这里称之为 <code>commit-b</code>。希望将 <code>patch</code> 分支下的编号为 <code>commit-b</code> 的 commit pick到 master 分支。</p><p>那么 <code>cherry-pick</code> 非常有用。</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">git</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">cherry-pick</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C3E88D;">提交</span><span style="color:#A6ACCD;">号</span><span style="color:#89DDFF;">&gt;</span><span style="color:#C3E88D;">...</span></span>
<span class="line"></span></code></pre></div><div class="language-git"><button title="Copy Code" class="copy"></button><span class="lang">git</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">git checkout master</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">git cherry-pick commit-b</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h2 id="交互式-rebase" tabindex="-1">交互式 rebase <a class="header-anchor" href="#交互式-rebase" aria-hidden="true">#</a></h2><p>交互式 rebase 指的是使用带参数 --interactive 的 rebase 命令, 简写为 -i。交互式 <code>git rebase -i</code> 会打开一个 GUI 界面。我们可以通过这个 GUI 界面对 要 merge 的 commit 进行排序后，生成一份新的 commit 副本。</p>`,85),c=[l];function o(n,p,r,d,g,h){return s(),a("div",null,c)}const C=e(i,[["render",o]]);export{u as __pageData,C as default};
