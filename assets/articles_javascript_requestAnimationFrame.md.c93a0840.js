import{_ as s,o as a,c as n,R as o}from"./chunks/framework.62e38f8b.js";const A=JSON.parse('{"title":"requestAnimationFrame - 编写优雅动画的秘籍","description":"","frontmatter":{},"headers":[],"relativePath":"articles/javascript/requestAnimationFrame.md","filePath":"articles/javascript/requestAnimationFrame.md","lastUpdated":1685340604000}'),e={name:"articles/javascript/requestAnimationFrame.md"},l=o(`<h1 id="requestanimationframe-编写优雅动画的秘籍" tabindex="-1">requestAnimationFrame - 编写优雅动画的秘籍 <a class="header-anchor" href="#requestanimationframe-编写优雅动画的秘籍" aria-label="Permalink to &quot;requestAnimationFrame - 编写优雅动画的秘籍&quot;">​</a></h1><p>requestAnimationFrame 是一个出来很久的 API 了，该 API 接受一个回调函数，浏览器会在<em><strong>恰当</strong></em>的时候回调执行该函数。注意，我把恰当二字着重强调了一下。根据文档相关的资料再结合自己在业务中用到该函数的理解，这里的恰当是指的是浏览器会在 render 页面完后，总是会将回调函数放在下一次渲染页面之前执行。我看到很多写相关的博客都在反复强调这个 api 是根据屏幕的刷新率执行回调，这是不完全对的。</p><p>例如有一台刷新率为 60hz 的显示器，60hz意味着每一秒刷新60次。 可通过计算得 <code>1s / 60hz = 16.6ms</code> 每 16.6ms 刷新一次屏幕。但是实际刷新时间可能会略有不同，具体取决于具体设备和其他因素。</p><p>即便抛开其他影响刷新率的因素，浏览器也并不会每隔16.6ms回调执行一次<code>requestAnimationFrame</code>，而是我之前提到过的将回调函数的执行时机安排在<em><strong>下一次即将重新绘制页面之前调用</strong></em>。大部分情况会在下一次显示刷新时进行，但如果浏览器正忙于执行其他任务或设备资源不足，则可能会延迟执行，因为我们知道js是单线程的，当前任务没有被执行完的时候，是绝对不会执行下一个任务的。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> TEN_SECONDS </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1000</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 10s</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> countTime </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> called </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">timeStamp</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">countTime</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">) </span><span style="color:#A6ACCD;">countTime</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">timeStamp</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">timeStamp</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">countTime</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">TEN_SECONDS</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">++</span><span style="color:#A6ACCD;">called</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">window</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">requestAnimationFrame</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">foo</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">window</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">requestAnimationFrame</span><span style="color:#A6ACCD;">(foo)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>假定在60hz的显示器下，called最终的值会累加到<code>600</code>左右（1000 * 10 / 16.6ms = 602.4096...）,但实际会根据当前页面其他的任务运行情况而决定。 下面是一个我在codesandbox上跑的一个示例，在60hz的显示器下，会回调执行600次左右，但是当不断回调执行requestAnimationFrame的同时鼠标滚动页面会发现执行次数就会减少很多。</p><iframe src="https://codesandbox.io/embed/intelligent-rubin-u68y5x?autoresize=1&amp;fontsize=14&amp;theme=dark&amp;view=preview" style="width:100%;height:500px;border:0;border-radius:4px;overflow:hidden;" title="intelligent-rubin-u68y5x" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe><p>前面叙述了很多关于<code>requestAnimationFrame()</code>是什么时机被调用的，接下来侧重说说这个API为什么能为业务代码带来优化。</p><p>我们编写的回调函数的执行时机最终完全交给了浏览器，浏览器内部会知道什么时机调用这个函数最佳与刷新率保持协调。</p><p>开发者利用<code>requestAnimationFrame()</code>能编写复杂的动画，其性能相比<code>setInterval()</code>更强，渲染更为流畅。而且当页面置于后台，<code>requestAnimationFrame()</code>会被暂停调用以提升性能和电池寿命。</p>`,10),p=[l];function t(r,c,i,F,y,D){return a(),n("div",null,p)}const C=s(e,[["render",t]]);export{A as __pageData,C as default};
