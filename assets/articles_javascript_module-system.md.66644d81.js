import{_ as s,f as a,h as o,R as l}from"./chunks/framework.0f2d6a02.js";const m=JSON.parse('{"title":"js 中的模块系统","description":"","frontmatter":{},"headers":[],"relativePath":"articles/javascript/module-system.md","lastUpdated":1680765169000}'),n={name:"articles/javascript/module-system.md"},p=l(`<h1 id="js-中的模块系统" tabindex="-1">js 中的模块系统 <a class="header-anchor" href="#js-中的模块系统" aria-label="Permalink to &quot;js 中的模块系统&quot;">​</a></h1><h2 id="为什么-javascript-需要模块系统" tabindex="-1">为什么 javascript 需要模块系统 <a class="header-anchor" href="#为什么-javascript-需要模块系统" aria-label="Permalink to &quot;为什么 javascript 需要模块系统&quot;">​</a></h2><p>在 es6 之前，并没有原生的模块系统，有的只是各路门派发明出来的 non-standard 的 module-system, 例如 node 中的<code>Commonjs</code>，Broswer 中的<code>AMD</code>、<code>UMD</code>等。</p><p>那么模块系统为什么会被创造出来呢？</p><p>先忘记模块系统，咱们穿越到那个刀耕火种的 es5、es3 时代，如果用 js 开发一个 web 项目，不可能将所有的 js 代码全部写在一个<code>&lt;script&gt;</code>标签中，因为随着项目的迭代，功能代码会不断地增加。那样会导致非常的难以维护，难以阅读。想一想在<code>&lt;script&gt;</code>中包含了上万行代码，简直是一坨 shit。</p><p>那么还有一种办法，就是将不同的业务功能写在不同的<code>&lt;script&gt;</code>中</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">foo.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">bar.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">baz.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>例如上面的代码,你可以将<code>foo</code>,<code>bar</code>和<code>baz</code>视作为各自的功能模块。比起将所有的功能写在一个<code>&lt;script&gt;</code>中, 这样的方式使得各个 script 的职责清晰了很多，业务功能划分到不同的 script 更容易阅读代码。</p><p><strong>but</strong> 假如<code>foo.js</code>和<code>bar.js</code>以及<code>baz.js</code>都需要用到一个相同的业务函数，不可能在每个 script 中 copy 一份这样的函数。 我们必须得将这个函数拎出来放到一个单独的<code>&lt;script&gt;</code>，还需要确保这个 script 必须最先被 loaded。</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">common.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">foo.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">bar.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">baz.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><p>这样虽然解决了代码无法复用的问题，但是可读性也变差了，因为你无法知道某个业务脚本中用到的函数是在哪个脚本中声明的。</p><p>更加致命的问题是，对于一些公共方法和公共变量，需要对变量命名约束要求极为严格，否则很容易被其他来自业务脚本中声明的变量所覆盖。</p><p>虽然所有的 script 脚本中声明的全局变量都处于同一个全局作用域下造成作用域污染，可以通过 IIFE 对代码进行包裹避免此种情况。但这种方法并不完美。</p><p>缺陷如下：</p><ul><li>每一个 IIFE 中返回对象的命名必须保证唯一，才能在其他模块正确的被访问；</li><li>代码写起来混乱不堪，<code>&lt;script&gt;</code>中的代码都需要包裹在一个匿名函数中来编写；</li></ul><p>这就是为什么 ES6 的 Module 姗姗来迟之前，民间发明出各种模块化规范的原因。</p><p>这一节不介绍<code>AMD</code>和<code>UMD</code>的规范，它们的历史使命在 E6 出来的那一刻就已经结束了。除非你想编写一个库需要兼容低版本的浏览器。</p><p>重点说说 CommonJS 和 ESM。 CommonJS 模块化从 Node.js 诞生之初就有了，在 node runTime 中。我们可以通过使用<code>require()</code>导入一个 js 文件。通过<code>module.expors</code>导出 js 文件中的变量，这很容易上手。</p><p>在 node14+正式实现了 ES Module，现在我们可以在 node 中同时使用 commonjs 和 esm 两种模块。如果的确想在 node 环境中使用 ES Module， 需要将你的 <code>*.js</code> 文件名变为 <code>*.mjs</code>，node 会将 <code>*.mjs</code> 文件遵循 es module 规范执行，而普通的 <code>*.js</code> 或者 <code>*.cjs</code> 仍遵循 commonjs 规范执行。</p><p>如果这样嫌麻烦的话，我们也可以在 <code>package.json</code> 设置 <code>type: &quot;module&quot;</code>, 这样会将项目内的所有 js 文件 treat as es module.</p><p>ES-Module 是 ECMA-262 官方定义的一个 JS 模块化规范。</p><p>ES-Module 定义了通过 <code>import</code> 导入一个 js 模块的功能，通过 <code>export</code> 导出一个 js 模块内的功能。</p><p>ES-Module 将所有导入的 js 文件视作为一个 module，多次重复导入一个 module, 则该 module 只会加载一次。（这一点和 Commonjs 的模块加载相同）</p><h3 id="模块导入" tabindex="-1">模块导入 <a class="header-anchor" href="#模块导入" aria-label="Permalink to &quot;模块导入&quot;">​</a></h3><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> defaultFetch </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./foo</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// import default export</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fetch</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./foo</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// import features named fetch</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> defaultFetch</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fetch</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./foo</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// import named features and default features at the same time</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">as</span><span style="color:#A6ACCD;"> allFetch </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./foo</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// import all features and named allNamedFetch to access</span></span>
<span class="line"></span></code></pre></div><p>需要注意的是最后一种导入方式应该不能被 tree-shaking 所支持。</p><h3 id="模块导出" tabindex="-1">模块导出 <a class="header-anchor" href="#模块导出" aria-label="Permalink to &quot;模块导出&quot;">​</a></h3><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> const foo </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// export default features</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> bar </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// export named features as bar</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fetchBar</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./bar</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// import fetchBar features from bar and export it as named export.</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./bar</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// import default features from bar and as current module default features export.</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">as</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">moduleA</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./bar</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// import default features from bar as current module named features and export it.</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">sayHi</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">as</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Default</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./bar</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// import named features from bar and as current module default features.</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./bar</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// import all named features from bar and export it.</span></span>
<span class="line"></span></code></pre></div><div class="warning custom-block"><p class="custom-block-title">注意</p><p><code>export * from &quot;./bar&quot;</code> 与 <code>import * as allFetch from &quot;./foo&quot;</code> 不同。 前者只会导入 bar 模块中所有的<strong>命名功能</strong>并导出。而后者会将 foo 模块中<strong>所有的导出</strong>并赋值给变量来访问。</p></div><h2 id="模块循环依赖" tabindex="-1">模块循环依赖 <a class="header-anchor" href="#模块循环依赖" aria-label="Permalink to &quot;模块循环依赖&quot;">​</a></h2><p>在 commonJS 与 ES Module 中，模块与模块之前相互引用对方所带来的一系列副作用是不同的。</p><p>什么是模块与模块相互引用？</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// bar.js</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> foo </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./foo.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// foo.js</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> bar </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./bar.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>可以从上面两段代码看出，执行脚本 bar.js 第一行代码时, 找到 foo.js 并执行，执行 foo.js，开始导入 bar.js 并执行。由此可看到两个脚本相互构成了一个模块依赖关系。</p><p>之前提高过，多次重复导入一个 module, 则该 module 只会执行一次，并且任何后续的导入将只会创建对相同导出的引用。</p><p>当执行 bar.js 时，es module 静态加载解析特性，将所有可提升的变量提升到模块最顶层作用域。接着加载 foo.js 导入 bar.js 中的 api，如果该 api 已经被初始化则可立即被执行。接着执行 foo.js 剩余可执行的所有代码后回到 bar.js 执行剩余的代码。</p><p><strong>需要记住的是，一旦某个模块被循环加载，只会输出已经执行了部分，没有执行的不输出。</strong></p><p>在 CommonJS 中循环依赖也是类似的策略，唯一不同的是 commonjs 脚本是动态加载的，导出的 api 不具有变量提升特性。</p><h2 id="es-module-和-commonjs-的区别" tabindex="-1">ES Module 和 CommonJS 的区别 <a class="header-anchor" href="#es-module-和-commonjs-的区别" aria-label="Permalink to &quot;ES Module 和 CommonJS 的区别&quot;">​</a></h2><ul><li>esm 只支持静态导入，必须将导入的模块声明在最顶部。cjs支持在模块内的任何作用域中动态加载其他模块，在加载模块时才进行导入分析。</li><li>cjs 的 this 是 <code>module.exports</code>，而 esm 中的 this 是 undefined。（node 中的 global 对象等同于浏览器环境中的 window）。</li><li>esm 中的导出的是一个只读的值的引用（如果值是对象类型），而在 cjs 中导出的是一个值的浅拷贝，可以直接对浅拷贝的对象进行操作。</li><li>如果导出是一个基本类型的值，则在 esm 中该值是一个只读的副本。</li><li>esm 支持 top level await, 这点在 cjs 中不被支持。</li></ul><h2 id="import-meta" tabindex="-1">i<wbr>mport.meta <a class="header-anchor" href="#import-meta" aria-label="Permalink to &quot;i&lt;wbr&gt;mport.meta&quot;">​</a></h2><p>i<wbr>mport.meta 对象包含了当前模块的信息，在内嵌脚本中，i<wbr>mport.meta.url 是文档的链接, 而对于外部脚本，i<wbr>mport.meta.url 的值则是脚本的链接</p><p>每一个 module 都有一个顶级作用域、每个模块的 this 都是 undefined。</p><h2 id="dynamic-import-动态导入" tabindex="-1">dynamic import 动态导入 <a class="header-anchor" href="#dynamic-import-动态导入" aria-label="Permalink to &quot;dynamic import 动态导入&quot;">​</a></h2><p>从 chrome63+ 开始，esm 也支持异步加载模块，可以通过 <code>import(assignExpression)</code> 动态加载一个模块并返回一个 pending 的 promise 对象，当模块被解析且加载完毕时，该 promise 的 state会被已实现（fulfilled），否则会被已拒绝（rejected）。需要注意的是这是一种特殊的语法，并不是一个函数,而是一个类函数表达式。应该是类似于 <code>await</code> 通过语法制导并进行一系列操作。</p>`,45),t=[p];function e(c,r,D,y,i,F){return a(),o("div",null,t)}const C=s(n,[["render",e]]);export{m as __pageData,C as default};
