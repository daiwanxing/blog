import{_ as s,c as n,o as a,a as p}from"./app.90452c48.js";const A=JSON.parse('{"title":"重新认识 typescript","description":"","frontmatter":{},"headers":[{"level":2,"title":"ts 中的结构化类型系统","slug":"ts-中的结构化类型系统","link":"#ts-中的结构化类型系统","children":[]},{"level":2,"title":"分布式条件类型 （Distributive conditional types）","slug":"分布式条件类型-distributive-conditional-types","link":"#分布式条件类型-distributive-conditional-types","children":[]},{"level":2,"title":"subtype 与 superType","slug":"subtype-与-supertype","link":"#subtype-与-supertype","children":[]}],"relativePath":"ts/type-narrow.md","lastUpdated":1676200671000}'),l={name:"ts/type-narrow.md"},o=p(`<h1 id="重新认识-typescript" tabindex="-1">重新认识 typescript <a class="header-anchor" href="#重新认识-typescript" aria-hidden="true">#</a></h1><h2 id="ts-中的结构化类型系统" tabindex="-1">ts 中的结构化类型系统 <a class="header-anchor" href="#ts-中的结构化类型系统" aria-hidden="true">#</a></h2><p>typescript 中的类型系统借鉴了数学中的集合的概念，让我先仔细回顾下大学线代课程的集合的概念</p><ul><li>集合是一组元素的组成的无序的结构，集合的基本单位就是元素，这些元素可以是数字、字符、字母。</li><li>集合的操作有并集、补集、交集、差集。</li><li>空集是一个特殊的集合，空集与任意集合的交集总是空集，空集与任意集合的并集是全集.</li></ul><p>在 typescript 中，定义以下的类型</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">SN</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">string</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">number</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 这里的类型SN就是string 和 number 的 supertype，它是类型string和类型number的并集.</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 类型SN 同时具有 string 和 number 全部属性.</span></span>
<span class="line"></span></code></pre></div><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">SN</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">string</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">number</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 将类型string和类型number做交集运算，取出它们公共的属性 作为类型SN, 这里的类型SN得到的其实是一个never类型</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 因为 类型string 和 类型 number 并无相交的属性.</span></span>
<span class="line"></span></code></pre></div><p>在集合中我们知道空集不属于任意集合，而在 typescript 中<code>never</code>类型同样也是不能被其他任何类型所分配。</p><ul><li><p><code>never</code> 与 其他类型 进行类型交叉 得到的永远是 <code>never</code>。</p></li><li><p><code>never</code> 与其他类型进行联合，得到的永远都是其他的类型。</p></li></ul><p><code>never</code>是 typescript 类型系统中的底端集合，而与之相反的，<code>unknown</code>是 typescript 中的顶端集合.</p><p><code>unknown</code>表示的是任何类型，如果一个变量的类型是<code>unknown</code>，那么它可以被任意其他的类型的变量所分配.<code>unknown</code>此外还具备类型收窄的功能.</p><p>什么是类型收窄？类型收窄会在代码块中的每个 if...else，switch...case 中，根据表达式返回的值的类型判断变量的类型.</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">print</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">arg</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">unknown</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">   </span><span style="color:#676E95;font-style:italic;">// isArray 如果为true， 那么 arg的值的类型会被限定为数组类型</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">Array</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">isArray</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">arg</span><span style="color:#F07178;">)) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// 在这个代码块, arg已经被收窄成了Array类型</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">arg</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">100</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">typeof</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">arg</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">string</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// arg 被收窄成了string类型</span></span>
<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// 在该if代码块中可以安全的使用 string原型上的方法</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">arg</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">split</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// safe</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>除了<code>never</code> 和 <code>unknown</code> 之外，还有一个特殊的类型 <code>any</code>。严格的来讲，<code>any</code>不是类型，如果一个变量的类型为<code>any</code>，那么这个变量就已经失去了类型保护，在该变量上调用相关方法或者进行算数运算操作返回的值也是<code>any</code>类型，ts 也无法检测到这些操作是否是合法的、有效的。作为开发者，已经无法具得知值的类型。在我看来，如果不到万不得已，是千万不要使用<code>any</code>类设置变量的类型的。</p><p>在一切需要用到 any 的地方，你最好用<code>unknown</code>去替代它。至少<code>unknown</code>搭配类型断言或者 ts 的类型收窄功能可以轻松的得到确切的值的类型，不会丢失类型保护。</p><h2 id="分布式条件类型-distributive-conditional-types" tabindex="-1">分布式条件类型 （Distributive conditional types） <a class="header-anchor" href="#分布式条件类型-distributive-conditional-types" aria-hidden="true">#</a></h2><p>我认为 ts 中的分布式条件类型有点类似于小学数学中的分配律， <code>(a+b)c = ab + bc</code>。</p><p>例如在 ts 中有如下一个条件类型</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">ABC</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">A</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">B</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">C</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">AB</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">A</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">D</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Distributive</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">T</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">T</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">ABC</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">T</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">never</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>在这里，如果把类型 AB 传入到泛型 T 中。</p><p>可得：<code>&#39;A&#39; extends ABC ? &#39;A&#39; : never | &#39;D&#39; extends ABC ? &#39;D&#39; : never</code></p><p>简化运算结果: <code>&#39;A&#39; | never =&gt; &#39;A&#39;</code>, 虽然传入给泛型 T 的是类型<code>AB</code>, 但是这里的 AB 是一个<code>union-type</code>，所以会将每个类型拆分出来判断是否能分配给类型<code>ABC</code>。</p><h2 id="subtype-与-supertype" tabindex="-1">subtype 与 superType <a class="header-anchor" href="#subtype-与-supertype" aria-hidden="true">#</a></h2><p>subType 和 superType 分别代表的是子类型和父类型</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// Fruit 是一个superType</span></span>
<span class="line"><span style="color:#C792EA;">type</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Fruit</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#F07178;">apperance</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">string</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#F07178;">shape</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">string</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// Apple 是一个 subType</span></span>
<span class="line"><span style="color:#C792EA;">interface</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Apple</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Fruit</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#F07178;">hasCore</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">boolean</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> apple</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Apple</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> fruit</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Fruit</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">fruit </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> apple</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// apple 可以被 分配给 fruit，因为Fruit类型定义的结构可以兼容Apple</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">apple </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> fruit</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// error, fruit不能分配给apple，因为fruit中没有apple类型中定义的hasCore属性</span></span>
<span class="line"></span></code></pre></div><p>在 ts 中，subType 的属性比 superType 更多，且更为具体。也就是说子类型是父类型的超集，父类型是子类型的子集。这点有别于数学中的集合。</p><p>在集合中，如果集合 A 的任意一个元素都属于集合 B，那么可得，集合 A 属于集合 B，或者集合 A 是集合 B 的子集。<strong><em>在集合中属性更少的集合是子集,这个与 ts 中的类型正好相反</em></strong>。</p><p>由 ts 中的子类型和父类型可以引申出来<code>协变</code>和 <code>逆变</code>两个概念。<code>协变</code>和<code>逆变</code>的概念很生涩难懂，我只会谈谈我的理解，并且理解的知识并不会脱离官方定义的概念中。</p><ul><li><code>协变</code> 是指 <code>subType</code> 可以分配给 <code>superType</code></li><li><code>逆变</code> 是指 <code>superType</code> 可以分配给<code>superType</code></li></ul><p>在前面的例子中, <code>fruit = apple</code>就是协变，因为<code>Apple</code>类型是<code>Fruit</code>类型的子类型，所以<code>Apple</code>类型的变量可以分配给<code>Fruit</code>类型的变量.</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">fruit </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> apple</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// fruit 依然可以使用Fruit类型上定义的属性和方法</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">fruit</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">shape</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// ok</span></span>
<span class="line"></span></code></pre></div><p>再来看看一个<code>逆变</code>的例子</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> printApple </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">apple</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Apple</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">apple</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">hasCore</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">apple has core</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> printFruit </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">fruit</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Fruit</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">   </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">fruit</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">shape</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">printFruit </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> printApple</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> fruit</span><span style="color:#89DDFF;">:</span><span style="color:#FFCB6B;">Fruit</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">   </span><span style="color:#F07178;">apperance</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">red</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">   shape: </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">circle</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#82AAFF;">printFruit</span><span style="color:#A6ACCD;">(fruit)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>如果将 <code>printFruit = printApple</code>，请问<code>printFruit()</code> 还能正常执行吗？</p><p>答案肯定是执行会报类型错误的，因为<code>printApple()</code>函数中访问了参数的<code>hasCore</code>属性，但是<code>printFruit</code>中的参数并未实现该属性。</p><p>但是反之，<code>printApple = printFruit</code>是完全可行的，因为后续调用<code>printApple()</code>会传入一个比<code>fruit</code>属性更为具体的<code>apple</code>，函数体内部的一切访问都会是正常的。</p><p>在<code>tsconfig.json</code>中,<code>strictFunctionType</code>值默认为<code>false</code>,也就意味着上面的例子是不会报错的，因为默认开启了双向协变，<code>subType</code>可以分配给<code>superType</code>，反之也可。在开启 <code>strictFunctionType: true</code> 后才会严格按照 <code>逆变</code> 来约束赋值关系。</p>`,37),e=[o];function t(c,r,y,F,i,D){return a(),n("div",null,e)}const d=s(l,[["render",t]]);export{A as __pageData,d as default};
