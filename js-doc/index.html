<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>事件循环 | 前端学习小站</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="用来记录自己平日的学习笔记">
    
    <link rel="preload" href="/frontend-notes/assets/css/0.styles.2ab3db1f.css" as="style"><link rel="preload" href="/frontend-notes/assets/js/app.971e1f9a.js" as="script"><link rel="preload" href="/frontend-notes/assets/js/2.e79caae7.js" as="script"><link rel="preload" href="/frontend-notes/assets/js/10.2128eda6.js" as="script"><link rel="prefetch" href="/frontend-notes/assets/js/11.7cd75672.js"><link rel="prefetch" href="/frontend-notes/assets/js/12.da472964.js"><link rel="prefetch" href="/frontend-notes/assets/js/3.e90d7c08.js"><link rel="prefetch" href="/frontend-notes/assets/js/4.e05c873c.js"><link rel="prefetch" href="/frontend-notes/assets/js/5.33233bc0.js"><link rel="prefetch" href="/frontend-notes/assets/js/6.498ab014.js"><link rel="prefetch" href="/frontend-notes/assets/js/7.0f1416dc.js"><link rel="prefetch" href="/frontend-notes/assets/js/8.08c1495b.js"><link rel="prefetch" href="/frontend-notes/assets/js/9.07c6de97.js">
    <link rel="stylesheet" href="/frontend-notes/assets/css/0.styles.2ab3db1f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/frontend-notes/" class="home-link router-link-active"><img src="/frontend-notes/logo.png" alt="前端学习小站" class="logo"> <span class="site-name can-hide">前端学习小站</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/frontend-notes/broswer-doc/" class="sidebar-link">浏览器笔记</a></li><li><a href="/frontend-notes/vue-router4-doc/" class="sidebar-link">vue-router4 笔记</a></li><li><a href="/frontend-notes/js-doc/" aria-current="page" class="active sidebar-link">javascript 笔记</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend-notes/js-doc/#事件循环" class="sidebar-link">事件循环</a></li><li class="sidebar-sub-header"><a href="/frontend-notes/js-doc/#web-worker" class="sidebar-link">Web Worker</a></li><li class="sidebar-sub-header"><a href="/frontend-notes/js-doc/#async-await" class="sidebar-link">async - await</a></li><li class="sidebar-sub-header"><a href="/frontend-notes/js-doc/#import-export" class="sidebar-link">import &amp; export</a></li><li class="sidebar-sub-header"><a href="/frontend-notes/js-doc/#defer-和-async" class="sidebar-link">defer 和 async</a></li></ul></li><li><a href="/frontend-notes/css-doc/" class="sidebar-link">css 笔记</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="事件循环"><a href="#事件循环" class="header-anchor">#</a> 事件循环</h2> <h4 id="什么是事件循环"><a href="#什么是事件循环" class="header-anchor">#</a> 什么是事件循环?</h4> <ol><li><p>引擎执行任务时，永远不会进行渲染（render），这里是指的是重新绘制DOM树，仅当任务完成之后才会重新绘制（浏览器每执行完一次宏任务之后就重新绘制DOM树）</p></li> <li><p>一个宏任务队列里包含着若干个微任务，也就是说每个宏任务执行之后，就先执行当前这个宏任务包含的微任务队列。微任务队列执行完毕之后，会触发一个render。紧接着再接着执行其他宏任务。宏任务是一个个的执行的，微任务是一队列一队列的执行的。我的理解，微任务是发生在其他宏任务（渲染DOM，事件，ajax）之前会被执行 <br></p></li></ol> <p>先来看一个例子</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;timeOut&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;promise&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;code&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>它们是如何执行的，或者说它们的执行顺序是什么？</p> <p>首先，加载script，这是一个宏任务，紧接着执行宏任务中的同步代码<code>alert(&quot;code&quot;)</code>,接着执行then函数里的callback，这是一个微任务。
前面我们提到过，微任务一定是在其他宏任务开始之前被执行，因为要确保microTask-queue中的每个micro-job的execute-enviroment是一致的。
执行完所有的微任务队列并出队之后，紧接着执行下一个宏任务，这里就是<code>setTimeout(() =&gt; (alert('timeOut'))</code>。</p> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p>如果宏任务队列为空，则js引擎会进入“休眠”状态。直到出现了宏任务，又开始了新一轮的事件循环。
如果需要执行一个耗时很长的计算任务，不应该阻塞事件循环，可以使用web-workers，这是在另一个并行的线程中去运行代码的方式。</p></div> <h2 id="web-worker"><a href="#web-worker" class="header-anchor">#</a> Web Worker</h2> <p>上面提到了web worker，本篇说说web-worker是一个什么技术。</p> <p>随着芯片的高速发展，现在的cpu动不动就是6核，8核甚至12核 以及 N * 2 个线程（N为核心数）。由于js是单线程，无法并行执行多个任务，根本发挥不出计算机的全部威力，而且有的计算任务特别耗时容易阻塞事件循环导致界面响应不及时，卡顿等。在这样的背景之下，web worker诞生了。</p> <p>web-worker可以在后台执行计算任务同时又不妨碍到主线程的执行，web-worker会将计算的到的结果返回给主线程。</p> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token comment">// index.js</span>
 <span class="token keyword">let</span> worker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">worker</span><span class="token punctuation">(</span><span class="token string">'worker.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 得到一个worker的实例， 初始化worker.js脚本文本，有一个self的全局对象或者称之为this</span>

 worker<span class="token punctuation">.</span><span class="token function">postmessage</span><span class="token punctuation">(</span><span class="token string">&quot;some info&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 发送给worker脚本</span>

 worker<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a ha</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code>    <span class="token comment">// worker.js</span>

    self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;message&quot;</span><span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// some info</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    self<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">&quot;a ha&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="custom-block warning"><p class="custom-block-title">注意</p> <ol><li>web-worker是无法操作DOM的，BOM中只能操作navigator和location对象</li> <li>web-worker受同源策略限制（分配给worker中运行的脚本资源必须与主线程同源）</li> <li>web-worker不能使用confirm, alert, 可以使用ajax</li> <li>web-worker一旦创建就会一直运行下去，除非手动释放</li> <li>web-worker和主线程不在一个context，通过post-message进行通信</li></ol></div> <h2 id="async-await"><a href="#async-await" class="header-anchor">#</a> async - await</h2> <p>async是Generator 函数的语法糖</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token comment">// 声明一个生成器函数</span>
    <span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">yield</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">yield</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">yield</span> x <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span>
        <span class="token keyword">yield</span> x <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回的是一个生成器函数的实例</span>
    bar<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// { value: 101, done: false } 每次调用实例的next方法就会返回一个对象，包含了yield的值和是否可继续调用next</span>
    <span class="token comment">// 执行到return语句的时候，剩下的yield不再执行</span>
</code></pre></div><h2 id="import-export"><a href="#import-export" class="header-anchor">#</a> import &amp; export</h2> <p>ES6 带来了ES Module的特性，模块的功能可以让我们更好的解耦代码功能逻辑，共用且不会与其他模块变量命名冲突</p> <ol><li>导入的几种方式</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token comment">// 导入的是module的默认导出</span>
    <span class="token keyword">import</span> moduleList <span class="token keyword">from</span> <span class="token string">&quot;./module.js&quot;</span><span class="token punctuation">;</span>

    <span class="token comment">// 导入的是module脚本中的命名变量：moduleA</span>
    <span class="token keyword">import</span> <span class="token punctuation">{</span> moduleA <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./module.js&quot;</span><span class="token punctuation">;</span> 

     <span class="token comment">// 导入的是module的默认导出与命名导出moduleA</span>
    <span class="token keyword">import</span> moduleList<span class="token punctuation">,</span> <span class="token punctuation">{</span> moduleA <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./module.js&quot;</span><span class="token punctuation">;</span>

    <span class="token comment">// 导入的module脚本所有导出（包括默认导出）到 allModule变量中</span>
    <span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> allModule <span class="token keyword">from</span> <span class="token string">&quot;./module.js&quot;</span><span class="token punctuation">;</span> 
</code></pre></div><ol start="2"><li>导出的几种方式</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token comment">// 导出的是一个默认导出foo变量 </span>
    <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> 

    <span class="token comment">// 导出的是一个命名导出bar变量</span>
    <span class="token keyword">export</span> <span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

    <span class="token comment">// 重新导出命名导出，从module脚本文件导出moduleA再导出给其他模块</span>
    <span class="token keyword">export</span> <span class="token punctuation">{</span> moduleA <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./module.js&quot;</span><span class="token punctuation">;</span>

    <span class="token comment">// 重新导出默认导出,</span>
    <span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./module.js&quot;</span><span class="token punctuation">;</span>

    <span class="token comment">// 重新将默认导出命名为命名导出</span>
    <span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token keyword">as</span> module <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./module.js&quot;</span><span class="token punctuation">;</span>

    <span class="token comment">// 重新导出所有的命名导出</span>
    <span class="token keyword">export</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token string">&quot;./module.js&quot;</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="defer-和-async"><a href="#defer-和-async" class="header-anchor">#</a> defer 和 async</h2> <p>script标签有一个defer和async属性，其兼容性在2021年已经非常不错了，IE本身就快淘汰了。</p> <img src="/frontend-notes/defer.png" alt="defer兼容性"> <p>总而言之，defer和async的出现的目的是为了防止js脚本阻塞DOM的解析，我们都知道渲染进程解析html文档生成DOM树时，如果遇到script标签，那么会停止解析。转而去加载js脚本并且等脚本加载完毕并且执行脚本完毕之后再去解析DOM，这样会徒增FP的渲染时间。一般通用的做法是将js脚本放到body最后面，这对于老旧浏览器是最优解，但是defer和async能够让我们有更多的优化。</p> <p>defer 和 async 的加载都是异步的，不会阻塞DOM的解析，唯一的区别在于，async是下载完毕之后就会被执行，执行的顺序和书写的顺序不一定保持一致（根据网络带宽决定）。
而带defer属性的脚本是在下载完毕之后，DOMCONTENTloaded事件触发之前会被执行。</p> <p>都说一图胜千言，下面搬运外网图片比较三种脚本的加载方式的特点：</p> <p>英语好的同学可以直接看外网链接<a href="https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html" target="_blank" rel="noopener noreferrer">async vs defer attributes<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><code>各个不同色块的含义</code></p> <p><img src="https://www.growingwiththeweb.com/images/2014/02/26/legend.svg" alt="legend"></p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;xxx.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
    <span class="token comment">// 可以看到先是解析html，接着解析到script标签，暂停html的解析，去下载脚本</span>
    <span class="token comment">// 脚本下载完毕之后开始执行脚本，等到执行完毕之后。继续解析后面的HTML</span>
</code></pre></div><p><img src="https://www.growingwiththeweb.com/images/2014/02/26/script.svg" alt="script normal">;</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;xxx.js&quot;</span> defer<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
    <span class="token comment">// 正常解析HTML，遇到script标签会异步下载</span>
    <span class="token comment">// 等到HTML解析完毕之后，DOMContentLoaded事件触发之前执行脚本 </span>
</code></pre></div><p><img src="https://www.growingwiththeweb.com/images/2014/02/26/script-defer.svg" alt="script normal">;</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><div class="highlighted"> </div><br></div><pre class="language-js"><code>    <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;xxx.js&quot;</span> async<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
    <span class="token comment">// 正常解析HTML，遇到script标签会异步下载</span>
    <span class="token comment">// 异步下载完毕之后会立即执行该脚本，执行脚本期间会阻塞HTML的解析</span>
</code></pre></div><p><img src="https://www.growingwiththeweb.com/images/2014/02/26/script-async.svg" alt="script normal">;</p> <p>我们应该根据不同的场景去使用对应的属性：</p> <ul><li>如果某些脚本需要依赖上一个脚本执行，推荐使用defer</li> <li>如果某些脚本想在下载完毕之后立即去执行，同时也不需要操作DOM也不依赖其他脚本， 推荐使用async</li> <li>如果脚本代码很小，推荐直接使用内联脚本放在body最后面</li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新时间:</span> <span class="time">2021/5/15上午5:13:19</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/frontend-notes/vue-router4-doc/" class="prev">
        vue-router4 笔记
      </a></span> <span class="next"><a href="/frontend-notes/css-doc/">
        css 笔记
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/frontend-notes/assets/js/app.971e1f9a.js" defer></script><script src="/frontend-notes/assets/js/2.e79caae7.js" defer></script><script src="/frontend-notes/assets/js/10.2128eda6.js" defer></script>
  </body>
</html>
