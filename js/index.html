<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>事件循环 | 前端学习小站</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="用来记录自己平日的学习笔记">
    
    <link rel="preload" href="/frontend-notes/assets/css/0.styles.2ab3db1f.css" as="style"><link rel="preload" href="/frontend-notes/assets/js/app.ed1d5a82.js" as="script"><link rel="preload" href="/frontend-notes/assets/js/2.e79caae7.js" as="script"><link rel="preload" href="/frontend-notes/assets/js/8.bbc7a56e.js" as="script"><link rel="prefetch" href="/frontend-notes/assets/js/10.5c69d105.js"><link rel="prefetch" href="/frontend-notes/assets/js/11.dc11cb9f.js"><link rel="prefetch" href="/frontend-notes/assets/js/3.2c99a915.js"><link rel="prefetch" href="/frontend-notes/assets/js/4.e05c873c.js"><link rel="prefetch" href="/frontend-notes/assets/js/5.33233bc0.js"><link rel="prefetch" href="/frontend-notes/assets/js/6.498ab014.js"><link rel="prefetch" href="/frontend-notes/assets/js/7.1ed5e31a.js"><link rel="prefetch" href="/frontend-notes/assets/js/9.e21e5a71.js">
    <link rel="stylesheet" href="/frontend-notes/assets/css/0.styles.2ab3db1f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/frontend-notes/" class="home-link router-link-active"><img src="/frontend-notes/logo.png" alt="前端学习小站" class="logo"> <span class="site-name can-hide">前端学习小站</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/frontend-notes/render-html/" class="sidebar-link">浏览器相关</a></li><li><a href="/frontend-notes/vue-router/" class="sidebar-link">vue-router4 特性</a></li><li><a href="/frontend-notes/js/" aria-current="page" class="active sidebar-link">javascript相关知识</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend-notes/js/#事件循环" class="sidebar-link">事件循环</a></li><li class="sidebar-sub-header"><a href="/frontend-notes/js/#web-worker" class="sidebar-link">Web Worker</a></li><li class="sidebar-sub-header"><a href="/frontend-notes/js/#async-await" class="sidebar-link">async - await</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="事件循环"><a href="#事件循环" class="header-anchor">#</a> 事件循环</h2> <h4 id="什么是事件循环"><a href="#什么是事件循环" class="header-anchor">#</a> 什么是事件循环?</h4> <ol><li><p>引擎执行任务时，永远不会进行渲染（render），这里是指的是重新绘制DOM树，仅当任务完成之后才会重新绘制（浏览器每执行完一次宏任务之后就重新绘制DOM树）</p></li> <li><p>一个宏任务队列里包含着若干个微任务，也就是说每个宏任务执行之后，就先执行当前这个宏任务包含的微任务队列。微任务队列执行完毕之后，会触发一个render。紧接着再接着执行其他宏任务。宏任务是一个个的执行的，微任务是一队列一队列的执行的。我的理解，微任务是发生在其他宏任务（渲染DOM，事件，ajax）之前会被执行 <br></p></li></ol> <p>先来看一个例子</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;timeOut&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;promise&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;code&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>它们是如何执行的，或者说它们的执行顺序是什么？</p> <p>首先，加载script，这是一个宏任务，紧接着执行宏任务中的同步代码<code>alert(&quot;code&quot;)</code>,接着执行then函数里的callback，这是一个微任务。
前面我们提到过，微任务一定是在其他宏任务开始之前被执行，因为要确保microTask-queue中的每个micro-job的execute-enviroment是一致的。
执行完所有的微任务队列并出队之后，紧接着执行下一个宏任务，这里就是<code>setTimeout(() =&gt; (alert('timeOut'))</code>。</p> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p>如果宏任务队列为空，则js引擎会进入“休眠”状态。直到出现了宏任务，又开始了新一轮的事件循环。
如果需要执行一个耗时很长的计算任务，不应该阻塞事件循环，可以使用web-workers，这是在另一个并行的线程中去运行代码的方式。</p></div> <h2 id="web-worker"><a href="#web-worker" class="header-anchor">#</a> Web Worker</h2> <p>上面提到了web worker，本篇说说web-worker是一个什么技术。</p> <p>随着芯片的高速发展，现在的cpu动不动就是6核，8核甚至12核 以及 N * 2 个线程（N为核心数）。由于js是单线程，无法并行执行多个任务，根本发挥不出计算机的全部威力，而且有的计算任务特别耗时容易阻塞事件循环导致界面响应不及时，卡顿等。在这样的背景之下，web worker诞生了。</p> <p>web-worker可以在后台执行计算任务同时又不妨碍到主线程的执行，web-worker会将计算的到的结果返回给主线程。</p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <ol><li>web-worker是无法操作DOM的，BOM中只能操作navigator和location对象</li> <li>web-worker受同源策略限制（分配给worker中运行的脚本资源必须与主线程同源）</li> <li>web-worker不能使用confirm, alert, 可以使用ajax</li> <li>web-worker一旦创建就会一直运行下去，除非手动释放</li> <li>web-worker和主线程不在一个context，通过post-message进行通信</li></ol></div> <h2 id="async-await"><a href="#async-await" class="header-anchor">#</a> async - await</h2> <p>async是Generator 函数的语法糖</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token comment">// 声明一个生成器函数</span>
    <span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">yield</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">yield</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">yield</span> x <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回的是一个生成器函数的实例</span>
    bar<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// { value: 101, done: false } 每次调用实例的next方法就会返回一个对象，包含了yield的值和是否可继续调用next</span>
    <span class="token comment">// 执行到return语句的时候，剩下的yield不再执行</span>
</code></pre></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新时间:</span> <span class="time">2021/5/6 上午8:54:35</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/frontend-notes/vue-router/" class="prev">
        vue-router4 特性
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/frontend-notes/assets/js/app.ed1d5a82.js" defer></script><script src="/frontend-notes/assets/js/2.e79caae7.js" defer></script><script src="/frontend-notes/assets/js/8.bbc7a56e.js" defer></script>
  </body>
</html>
